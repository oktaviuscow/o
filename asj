local Library = loadstring(game:HttpGetAsync("https://github.com/ActualMasterOogway/Fluent-Renewed/releases/latest/download/Fluent.luau"))()
local SaveManager = loadstring(game:HttpGetAsync("https://raw.githubusercontent.com/ActualMasterOogway/Fluent-Renewed/master/Addons/SaveManager.luau"))()
local InterfaceManager = loadstring(game:HttpGetAsync("https://raw.githubusercontent.com/ActualMasterOogway/Fluent-Renewed/master/Addons/InterfaceManager.luau"))()
local MarketplaceService = game:GetService("MarketplaceService")
local gamename = MarketplaceService:GetProductInfo(game.PlaceId).Name
local ApelHubFolder = "Apel Hub"


local Window = Library:CreateWindow({
    Title = "Apel Hub",
    SubTitle = tostring(gamename),
    TabWidth = 160,
    Size = UDim2.fromOffset(600, 400),
    Acrylic = false, -- The blur may be detectable, setting this to false disables blur entirely
    Resize = true, -- Resize this ^ Size according to a 1920x1080 screen, good for mobile users but may look weird on some devices
    MinSize = Vector2.new(250, 250),
    Acrylic = false, -- The blur may be detectable, setting this to false disables blur entirely
    Theme = "Dark",
    MinimizeKey = Enum.KeyCode.LeftControl -- Used when theres no MinimizeKeybind
})


local Tabs = {
    Credits = Window:CreateTab({Title = "Credits", Icon = "book"}),
    Farm = Window:CreateTab({ Title = "Farming", Icon = "align-center" }),
    Trials = Window:CreateTab({Title = "Trial", Icon = "apple"}),
    Eggs = Window:CreateTab({Title = "Eggs", Icon = "egg"}),
    AutoBuy = Window:CreateTab({Title = "Auto Buy", Icon = "shopping-cart"}),
    Rerolls = Window:CreateTab({Title = "Auto Rolls", Icon = "refresh-ccw"}),
    Misc = Window:CreateTab({Title = " Misc", Icon = "diamond"}),
    Settings = Window:CreateTab({ Title = "Settings", Icon = "settings" })

}

Tabs.Credits:CreateParagraph("Aligned Paragraph", {
    Title = "Discord",
    Content = "https://discord.gg/4gDAbj2VXG\n Dev - Apelsinka",
    TitleAlignment = "Middle",
    ContentAlignment = Enum.TextXAlignment.Center
})

Tabs.Credits:CreateButton({
    Title = "Copy Discord link",
    Description = "Click it",
    TitleAlignment = "Middle",
    ContentAlignment = Enum.TextXAlignment.Center,
    Callback = function()
        local link = "https://discord.gg/4gDAbj2VXG"
        setclipboard(link)
    end
})


local Options = Library.Options
local Players = game:GetService("Players")
local player = Players.LocalPlayer
local character = player.Character
    local bb=game:service'VirtualUser'
    game:service'Players'.LocalPlayer.Idled:connect(function()
    bb:CaptureController()bb:ClickButton2(Vector2.new())end)


local folderName = "Apel Hub"
local PositionfileName = "Saved Position.txt"
local WorldfileName = "Saved World.txt"    
local PositionfolderPath = folderName .. "\\" .. PositionfileName
local WorldfolderPath = folderName .. "\\" .. WorldfileName
local RarityfileName = "Saved Rarities.txt"
local RarityfolderPath = folderName .. "\\" .. RarityfileName
local EnabledOrDisabledName = "Saved EnabledOrDisabled.txt"
local EnabledOrDisabledfolderPath = folderName .. "\\" .. EnabledOrDisabledName

-- Проверяем, существует ли папка
if not isfolder(folderName) then
    makefolder(folderName)  -- Создаем папку, если она не существует
    print("Папка '" .. folderName .. "' была создана.")
else
    print("Папка '" .. folderName .. "' уже существует.")
end

-- Проверяем, существует ли файл
if not isfile(PositionfolderPath) or not isfile(WorldfolderPath) or not isfile(RarityfolderPath) or not isfile(EnabledOrDisabledfolderPath) then
    local positionforsave = "139.8529052734375, 377.14923095703125, 3295.7548828125"
    local worldforsave = "Piece Village"
    if not isfile(PositionfolderPath) then
    writefile(PositionfolderPath, tostring(positionforsave))  -- Записываем значение в файл
    end
    if not isfile(WorldfolderPath) then
    writefile(WorldfolderPath, worldforsave)
    end
    if not isfile(RarityfolderPath) then
    writefile(RarityfolderPath, "")
    end
    if not isfile(EnabledOrDisabledfolderPath) then
        writefile(EnabledOrDisabledfolderPath, "false")
    end
    print("Файл '" .. PositionfileName.."and"..WorldfileName .. "' был создан и записан.")
else
    print("Файл '" .. PositionfileName.."and"..WorldfileName .. "' был создан и записан.")
end

local sigma = Players.LocalPlayer

-- Функция для получения существующих unitid из petsFolder
local function getExistingUnitIds2(petsFolder)
    local existingUnitIds2 = {}
    for _, child in pairs(petsFolder:GetChildren()) do
        if child:IsA("Folder") then
            table.insert(existingUnitIds2, child.Name) -- Добавляем имя папки (unitid) в список
        end
    end
    return existingUnitIds2
end

-- Функция для обновления petsFolder
local function updatePetsFolder()
    local success, sigma2 = pcall(function()
        return require(sigma.PlayerScripts.Shalom)
    end)

    if not success then
        return
    end

    -- Создаем папку Pets в LocalPlayer, если она еще не существует
    local petsFolder = sigma:FindFirstChild("Pets")
    if not petsFolder then
        petsFolder = Instance.new("Folder")
        petsFolder.Name = "Pets"
        petsFolder.Parent = sigma
    end

    -- Получаем существующие unitid
    local existingUnitIds2 = getExistingUnitIds2(petsFolder)

    -- Получаем таблицу питомцев напрямую
    local petsData = sigma2.Data.Pets
    if type(petsData) == "table" then
        for unitid, d in pairs(petsData) do
            -- Проверяем, существует ли папка с таким именем
            local petFolder = petsFolder:FindFirstChild(tostring(unitid))
            if not petFolder then
                -- Если папка не существует, создаем её
                petFolder = Instance.new("Folder")
                petFolder.Name = tostring(unitid) -- Устанавливаем имя папки как unitid
                petFolder.Parent = petsFolder -- Добавляем папку в Pets
            end

            table.insert(existingUnitIds2, unitid)

            -- Устанавливаем атрибуты
            for nameofstat, valueofstat in pairs(d) do
                local currentValue = petFolder:GetAttribute(nameofstat)
                if currentValue == nil or currentValue ~= valueofstat then
                    petFolder:SetAttribute(nameofstat, valueofstat) -- Устанавливаем атрибут
                end
            end
        end
    end

    -- Удаляем папки питомцев, которые не соответствуют существующим unitid
    for _, child in pairs(petsFolder:GetChildren()) do
        if child:IsA("Folder") and not table.find(existingUnitIds2, child.Name) then
            child:Destroy() -- Удаляем папку
        end
    end
end

-- Запускаем корутину для постоянного обновления
coroutine.wrap(function()
    while true do
        updatePetsFolder() -- Обновляем petsFolder
        task.wait() -- Ждем 5 секунд перед следующим обновлением
    end
end)()


    local ShalomPath = player.PlayerScripts.Shalom
    local function getExistingAvatars(AvatarsFolder)
        local existingAvatars = {}
        for _, child in pairs(AvatarsFolder:GetChildren()) do
            if child:IsA("Folder") then
                table.insert(existingAvatars, child.Name) -- Добавляем имя папки (AvatarName) в список
            end
        end
        return existingAvatars
    end

    local function updateAvatarsFolder()
        local success, Shalom = pcall(function()
            return require(ShalomPath)
        end)
    
        if not success then
            return
        end

        local Avatars = Shalom.Data.Inventory.Avatars
        
        local AvatarsFolder = player:FindFirstChild("Avatars")
        if not AvatarsFolder then
            AvatarsFolder = Instance.new("Folder")
            AvatarsFolder.Name = "Avatars"
            AvatarsFolder.Parent = player
        end
        local ExistingAvatars = getExistingAvatars(AvatarsFolder)

        if type(Avatars) == "table" then
            for AvatarName, d in pairs(Avatars) do
                -- Проверяем, существует ли папка с таким именем
                local AvatarFolder = AvatarsFolder:FindFirstChild(tostring(AvatarName))
                if not AvatarFolder then
                    -- Если папка не существует, создаем её
                    AvatarFolder = Instance.new("Folder")
                    AvatarFolder.Name = tostring(AvatarName) -- Устанавливаем имя папки как unitid
                    AvatarFolder.Parent = AvatarsFolder -- Добавляем папку в Pets
                end
    
                table.insert(ExistingAvatars, AvatarName)
    
            end
        end

        for _, child in pairs(AvatarsFolder:GetChildren()) do
            if child:IsA("Folder") and not table.find(ExistingAvatars, child.Name) then
                child:Destroy() -- Удаляем папку
            end
        end

    end

    coroutine.wrap(function()
        while true do
            updateAvatarsFolder() -- Обновляем petsFolder
            task.wait() -- Ждем 5 секунд перед следующим обновлением
        end
    end)()

    local ShalomPath = player.PlayerScripts.Shalom
    local function getExistingStock(StockFolder)
        local existingStock = {}
        for _, child in pairs(StockFolder:GetChildren()) do
            if child:IsA("Folder") then
                table.insert(existingStock, child.Name) -- Добавляем имя папки (AvatarName) в список
            end
        end
        return existingStock
    end

    local function updateStockFolder()
        local success, Shalom = pcall(function()
            return require(ShalomPath)
        end)
    
        if not success then
            return
        end
    
        local Stock = Shalom.Data.Merchant.List
    
        local StockFolder = player:FindFirstChild("Stock")
        if not StockFolder then
            StockFolder = Instance.new("Folder")
            StockFolder.Name = "Stock"
            StockFolder.Parent = player
        end
        local ExistingStock = getExistingStock(StockFolder)
    
        if type(Stock) == "table" then
            for StockName, NumberOfStock in pairs(Stock) do
                -- Проверяем, существует ли папка с таким именем
                local CheckStockFolder = StockFolder:FindFirstChild(tostring(StockName))
                if not CheckStockFolder then
                    -- Если папка не существует, создаем её
                    CheckStockFolder = Instance.new("Folder")
                    CheckStockFolder.Name = tostring(StockName) -- Устанавливаем имя папки как unitid
                    CheckStockFolder.Parent = StockFolder -- Добавляем папку в Stock
                end
    
                table.insert(ExistingStock, StockName)
    
                -- Заменяем пробелы на символы подчеркивания для атрибута
                local safeAttributeName = StockName:gsub(" ", "_")
    
                local currentValue = CheckStockFolder:GetAttribute(safeAttributeName)
                if currentValue == nil or currentValue ~= NumberOfStock then
                    CheckStockFolder:SetAttribute("Amount", NumberOfStock) -- Устанавливаем атрибут
                end
            end
        end
    
        for _, child in pairs(StockFolder:GetChildren()) do
            if child:IsA("Folder") and not table.find(ExistingStock, child.Name) then
                child:Destroy() -- Удаляем папку
            end
        end
    end

    coroutine.wrap(function()
        while true do
            updateStockFolder() -- Обновляем petsFolder
            task.wait() -- Ждем 5 секунд перед следующим обновлением
        end
    end)()


do

    local AutoClick = Tabs.Misc:CreateToggle("Auto Click", {Title = "Auto Click", Default = false, Description = ""})

    AutoClick:OnChanged(function(State)-- Auto Click
        getgenv().AutoClicking = State
        while getgenv().AutoClicking == true do
            if not getgenv().AutoClicking == true then return end
                task.wait(0.01)
                game:GetService("ReplicatedStorage"):WaitForChild("Remotes"):WaitForChild("Bridge"):FireServer("Enemies", "World", "Click")
        end
    end)

    

    local AutoCollect = Tabs.Misc:CreateToggle("Auto Collect", {Title = "Auto Collect Drops", Default = false, Description = ""})

    local dropfolder = game:GetService("Workspace").Client.Drops

    local function findHumanoidRootPart()
        local player = game.Players.LocalPlayer
        local character = player.Character
        if character then
            local rootPart = character:FindFirstChild("HumanoidRootPart")
            if rootPart then
                return rootPart -- Если найден, возвращаем его
            end
        end
    end

    AutoCollect:OnChanged(function(State) -- Auto Collect Drops
        getgenv().AutoCollecting =  State
        while getgenv().AutoCollecting == true do
            if not getgenv().AutoCollecting == true then return end
                local rootPart = findHumanoidRootPart()
    
                task.wait()
                for i, v in ipairs(dropfolder:GetChildren()) do
                    v.CFrame = rootPart.CFrame
                end
        end
    end)

    local EnemiesFolder = workspace.Client.Enemies
    local ServerEnemiesFolder = workspace.Server.Enemies
    local Enemies = {}
    local nameSet = {}

    if EnemiesFolder then
        for _, enemy in ipairs(EnemiesFolder:GetChildren()) do
            local enemyname = enemy.Name
            if enemyname and not nameSet[enemyname] then
                table.insert(Enemies, enemyname)
                nameSet[enemyname] = true
            end
        end
    end
    
    local EnemyDropdown = Tabs.Farm:CreateDropdown("Enemy", {Title = "Enemy Selector", Description = "Select enemy for farm", Values = Enemies, Multi = true, Default = {}})

    local CurrentEnemy = {}
    EnemyDropdown:OnChanged(function(Value)
        for Value, State in next, Value do
            table.insert(CurrentEnemy, Value)
        end
    end)

    function EnemyDropdown:GetSelectedValues()
        local selected = {}
        for value, state in pairs(self.Value) do
            if state then
                table.insert(selected, value)
            end
        end
        return selected
    end

    local function RefreshEnemyDropdownWithNewEnemies()
        local newEnemies = {}
        local nameSet = {}
        if EnemiesFolder then
            for _, enemy in ipairs(EnemiesFolder:GetChildren()) do
                local enemyname = enemy.Name
                if enemyname and not nameSet[enemyname] then
                    table.insert(newEnemies, enemyname)
                    nameSet[enemyname] = true
                end
            end
        end
        EnemyDropdown:SetValues(newEnemies)
    end
    local AutoFarmSelectedMobs = Tabs.Farm:CreateToggle("AutoFarm", {Title = "Auto Farm Selected Mobs", Default = false, Description = ""})

    local AutoFarmWithTeleport = Tabs.Farm:CreateToggle("AutoFarm", {Title = "Auto Farm With Teleport", Default = false, Description = ""})

    AutoFarmWithTeleport:OnChanged(function(state)
        getgenv().AutoFarmWithTeleport = state
    end)

    Tabs.Farm:CreateButton({
        Title = "Refresh Enemies",
        Description = "Update Enemies Dropdown with your current enemies on map",
        Callback = function()
            RefreshEnemyDropdownWithNewEnemies()
        end
    })

    local function containsValue(value, table)
        for _, v in ipairs(table) do
            if v == value then
                return true
            end
        end
        return false
    end

    local Players = game:GetService("Players")
    local player = Players.LocalPlayer

    
    
    local teleportRadius = 10
    local teleportRadiusForPet = 20
    

    local function findNearestEnemy(selectedEnemies)
        local closestEnemy = nil
        local closestDistance = math.huge
        local rootPart = findHumanoidRootPart()
        for _, enemy in pairs(ServerEnemiesFolder:GetDescendants()) do
            if enemy:IsA("Part") and tonumber(enemy:GetAttribute("Health")) > 0 then
                local distance = (rootPart.Position - enemy.Position).Magnitude
    
                if containsValue(enemy.Name, selectedEnemies) and distance < closestDistance then
                    closestDistance = distance
                    closestEnemy = enemy
                end
            end
        end
    
        return closestEnemy
    end

    local function findNearestEnemyWithoutContains()
        local closestEnemy = nil
        local closestDistance = math.huge
        local rootPart = findHumanoidRootPart()
        for _, enemy in pairs(ServerEnemiesFolder:GetDescendants()) do
            if enemy:IsA("Part") and tonumber(enemy:GetAttribute("Health")) > 0 then
                local distance = (rootPart.Position - enemy.Position).Magnitude
    
                if distance < closestDistance then
                    closestDistance = distance
                    closestEnemy = enemy
                end
            end
        end
    
        return closestEnemy
    end
    


    local function getEquipedPets()
        local EquipedPets = {}
        local player = game:GetService("Players").LocalPlayer  -- Получаем локального игрока
    
        for _, value in ipairs(workspace.Server.Pets:GetChildren()) do
            local inputString = value.Name
            local nickname = string.match(inputString, "^(.-)---")
    
            if nickname then
                if nickname == tostring(player) then
                    -- Проверяем, существует ли объект Info
                    if value:FindFirstChild("Info") then
                        local info = value.Info  -- Сохраняем ссылку на Info
    
                        -- Проверяем, существует ли объект Player внутри Info
                        if info:FindFirstChild("Player") then
                            if info.Player.Value == player then
                                table.insert(EquipedPets, value:GetAttribute("ID"))
                            end
                        else
                            print("Player не найден в Info.")
                        end
                    else
                        print("Info не найден у питомца:", value.Name)
                    end
                end
            end
        end
    
        return EquipedPets
    end

    local function getPets()
        local pets = {}
        local player = game:GetService("Players").LocalPlayer  -- Получаем локального игрока
    
        for _, value in ipairs(workspace.Server.Pets:GetChildren()) do
            local inputString = value.Name
            local nickname = string.match(inputString, "^(.-)---")
    
            if nickname then
                if nickname == tostring(player) then
                    -- Проверяем, существует ли объект Info
                    if value:FindFirstChild("Info") then
                        local info = value.Info  -- Сохраняем ссылку на Info
    
                        -- Проверяем, существует ли объект Player внутри Info
                        if info:FindFirstChild("Player") then
                            if info.Player.Value == player then
                                table.insert(pets, value)
                            end
                        else
                            print("Player не найден в Info у питомца:", value.Name)
                        end
                    else
                        print("Info не найден у питомца:", value.Name)
                    end
                end
            end
        end
    
        return pets
    end


    local function teleportMeToNearestEnemyWithContains()
        local selectedEnemies = {}
        for _, value in ipairs(EnemyDropdown:GetSelectedValues()) do
            table.insert(selectedEnemies, value)
        end
        local rootPart = findHumanoidRootPart()
        local nearestEnemy = findNearestEnemy(selectedEnemies)

        if nearestEnemy then
            local targetRootPart = nearestEnemy
            local distanceToEnemy = (rootPart.Position - targetRootPart.Position).Magnitude
            if distanceToEnemy > teleportRadius then
                rootPart.CFrame = CFrame.new(targetRootPart.Position + Vector3.new(0, 0, 3), targetRootPart.Position) -- Телепортируемся за врага
            end
        end
    end

    local function teleportPetsToNearestEnemyWithContains()
        local selectedEnemies = {}
        for _, value in ipairs(EnemyDropdown:GetSelectedValues()) do
            table.insert(selectedEnemies, value)
        end
    
        local nearestEnemy = findNearestEnemy(selectedEnemies)

        if nearestEnemy then
            local targetRootPart = nearestEnemy
            local pets = getPets()
            for i, v in pets do
                    local petrootpart = v.HumanoidRootPart
                    local distanceToPet = (targetRootPart.Position - petrootpart.Position).Magnitude
            
                    if distanceToPet > teleportRadiusForPet then
                        petrootpart.CFrame = CFrame.new(targetRootPart.Position + Vector3.new(0, 0, 3), targetRootPart.Position) -- Телепортируем питомца за врага
                    end
            end
        end
    end

    local function teleportMeToNearestEnemyWithoutContains()

    
        local nearestEnemy = findNearestEnemyWithoutContains()
        local rootPart = findHumanoidRootPart()
        if nearestEnemy then
            local targetRootPart = nearestEnemy
            local distanceToEnemy = (rootPart.Position - targetRootPart.Position).Magnitude
            if distanceToEnemy > teleportRadius then
                rootPart.CFrame = CFrame.new(targetRootPart.Position + Vector3.new(0, 0, 3), targetRootPart.Position) -- Телепортируемся за врага
            end
        end
    end

    local function teleportPetsToNearestEnemyWithoutContains()

    
        local nearestEnemy = findNearestEnemyWithoutContains()

        if nearestEnemy then
            local targetRootPart = nearestEnemy
            local pets = getPets()
            for i, v in pets do
                    local petrootpart = v.HumanoidRootPart
                    local distanceToPet = (targetRootPart.Position - petrootpart.Position).Magnitude
            
                    if distanceToPet > teleportRadiusForPet then
                        petrootpart.CFrame = CFrame.new(targetRootPart.Position + Vector3.new(0, 0, 3), targetRootPart.Position) -- Телепортируем питомца за врага
                    end
            end
        end
    end




    local function sendPetsOnEnemy()
        local selectedEnemies = {}
        for _, value in ipairs(EnemyDropdown:GetSelectedValues()) do
            table.insert(selectedEnemies, value)
        end
        local nearestEnemy = findNearestEnemy(selectedEnemies)
        local EquipedPets = getEquipedPets()
        for i, v in EquipedPets do
            local rnpetcheck = tostring(game:GetService("Players").LocalPlayer).."---"..v
            if not nearestEnemy:FindFirstChild("Info"):FindFirstChild("Pets"):FindFirstChild(rnpetcheck) then
                teleportPetsToNearestEnemyWithContains()
            local args = {
                [1] = "General",
                [2] = "Pets",
                [3] = "Attack",
                [4] = v,
                [5] = nearestEnemy
            }
            
            game:GetService("ReplicatedStorage"):WaitForChild("Remotes"):WaitForChild("Bridge"):FireServer(unpack(args))
        end
        end
    end

    local function sendPetsOnNearestEnemy()
        local nearestEnemy = findNearestEnemyWithoutContains()
        local EquipedPets = getEquipedPets()
    
        if nearestEnemy then  -- Проверяем, что nearestEnemy существует
            local info = nearestEnemy:FindFirstChild("Info")  -- Находим объект Info
    
            if info then  -- Проверяем, существует ли Info
                for i, v in EquipedPets do
                    local rnpetcheck = tostring(game:GetService("Players").LocalPlayer).."---"..v
    
                    if info:FindFirstChild("Pets") then  -- Проверяем, существует ли Pets
                        if not info.Pets:FindFirstChild(rnpetcheck) then
                            teleportPetsToNearestEnemyWithoutContains()
                            local args = {
                                [1] = "General",
                                [2] = "Pets",
                                [3] = "Attack",
                                [4] = v,
                                [5] = nearestEnemy
                            }
    
                            game:GetService("ReplicatedStorage"):WaitForChild("Remotes"):WaitForChild("Bridge"):FireServer(unpack(args))

                        end
                    else
                        print("Pets не найдены в Info.")
                    end
                end
            else
                print("Info не найден у ближайшего врага.")
            end
        else
            print("Ближайший враг не найден.")
        end
    end

    getgenv().Busy = nil
    AutoFarmSelectedMobs:OnChanged(function(state)
        getgenv().AutoFarm = state
    
        while getgenv().AutoFarm do
            task.wait()
            local Values = {}
            for _, value in ipairs(EnemyDropdown:GetSelectedValues()) do
                table.insert(Values, value)
            end
            for i, v in ipairs(workspace.Client.Maps:GetChildren()) do
                if v.Name == "Lobby" then
                    getgenv().Busy = true
                else
                    getgenv().Busy = false
                end
            end
            -- Проверяем состояние врагов в каждом цикле
            for _, enemy in ipairs(ServerEnemiesFolder:GetDescendants()) do
                if enemy:IsA("Part") and containsValue(enemy.Name, Values) then
                    -- Проверяем здоровье и состояние врага
                    if tonumber(enemy:GetAttribute("Health")) > 0 and getgenv().AutoFarm == true and getgenv().Busy == false then
                        if getgenv().AutoFarmWithTeleport == true and getgenv().Busy == false then
                            teleportMeToNearestEnemyWithContains()
                        end
                        sendPetsOnEnemy()
                    end
                end
            end
        end
    end)
    
    local AutoFarmNearest = Tabs.Farm:CreateToggle("Auto Farm Nearest", {Title = "Auto Farm Nearest", Default = false, Description = ""})
    AutoFarmNearest:OnChanged(function(state)
        getgenv().AutoFarmNearest = state
        while getgenv().AutoFarmNearest do
            task.wait()
            for i, v in ipairs(workspace.Client.Maps:GetChildren()) do
                if v.Name == "Lobby" then
                    getgenv().Busy = true
                else
                    getgenv().Busy = false
                end
            end
            for _, enemy in ipairs(ServerEnemiesFolder:GetDescendants()) do
                if enemy:IsA("Part") then
                    -- Проверяем здоровье и состояние врага
                    if tonumber(enemy:GetAttribute("Health")) > 0 and getgenv().AutoFarmNearest == true and getgenv().Busy == false then
                        sendPetsOnNearestEnemy()
                        if getgenv().AutoFarmWithTeleport == true and getgenv().Busy == false then
                            teleportMeToNearestEnemyWithoutContains()
                        end
                        wait(0.1)

                    end
                end
            end
        end
        
    end)

    local eggfolder = workspace.Server.Eggs
    local egglist = {}
    local eggset = {}
    if eggfolder then
        for _, egg in ipairs(eggfolder:GetChildren()) do
            local eggname = egg.Name
            if eggname and not eggset[eggname] then
                table.insert(egglist, eggname)
                eggset[eggname] = true
            end
        end
    end

    local currenteggforfarm = nil
    local EggsDropDown = Tabs.Eggs:CreateDropdown("Eggs", {Title = "Select Egg For Auto Open", Description = "", Values = egglist, Multi = false, Default = 1,})
    EggsDropDown:OnChanged(function(Value)
        currenteggforfarm = Value
        print(currenteggforfarm)
    end)

    local AutoOpenEggs = Tabs.Eggs:CreateToggle("Auto Open Eggs", {Title = "Auto Open Selected Egg", Default = false, Description = ""})

    AutoOpenEggs:OnChanged(function(state)
        getgenv().AutoOpenEggs = state
        while getgenv().AutoOpenEggs do
            task.wait(0.01)

            local args = {
                [1] = "General",
                [2] = "Eggs",
                [3] = "Multi",
                [4] = currenteggforfarm,
                [5] = "Yen"
            }
            
            game:GetService("ReplicatedStorage"):WaitForChild("Remotes"):WaitForChild("Bridge"):FireServer(unpack(args))
            
        end
    end)
    local function loadRarities()
        if isfile(RarityfolderPath) then
            local savedRaritiesString = readfile(RarityfolderPath)
            local savedRarities = {} -- Создаем таблицу для сохраненных рарностей
            for rarity in string.gmatch(savedRaritiesString, "([^,]+)") do
                table.insert(savedRarities, rarity:match("^%s*(.-)%s*$")) -- Убираем пробелы
            end
            return savedRarities -- Возвращаем таблицу сохраненных рарностей
        else
            print("Файл рарностей не найден.")
            return {}
        end
    end
    
    -- Функция для обновления файла с рарностями
    local function updateRaritiesFile(selectedValues)
        local currentRarities = loadRarities() -- Загружаем текущие рарности из файла
    
        -- Создаем таблицу для обновленных рарностей
        local updatedRarities = {}
    
        -- Добавляем новые рарности
        for _, rarity in pairs(selectedValues) do
            if not table.find(currentRarities, rarity) then
                table.insert(updatedRarities, rarity) -- Добавляем новую рарность
            end
        end
    
        -- Добавляем существующие рарности
        for _, rarity in pairs(currentRarities) do
            if table.find(selectedValues, rarity) then
                table.insert(updatedRarities, rarity) -- Сохраняем рарность, если она все еще выбрана
            end
        end
    
        -- Записываем обновленный список в файл
        local raritiesString = table.concat(updatedRarities, ", ")
        writefile(RarityfolderPath, raritiesString) -- Записываем строку в файл
    end
    
    local function loadSavedStateForAutoSell()
        local savedstate = readfile(EnabledOrDisabledfolderPath)
        if savedstate:lower() == "true" then
            return true
        elseif savedstate:lower() == "false" then
            return false
        else
            error("Содержимое файла не является логическим значением (true/false).")
        end
    end
    -- Загружаем ранее сохраненные рарности при старте
    local savedRarities = loadRarities()
    local savedstateforautosell = loadSavedStateForAutoSell()

    local AutoSellDropDown = Tabs.Eggs:CreateDropdown("Auto Sell", {Title = "Select Rarity for Auto Sell", Description = "", Values = {"Common", "Uncommon", "Rare", "Epic", "Legendary", "Mythical"}, Multi = true, Default = savedRarities })
    
    local AutoSell = Tabs.Eggs:CreateToggle("Auto Sell", {Title = "Auto sell Selected Rarities", Default = savedstateforautosell, Description = ""})

    function AutoSellDropDown:GetSelectedValues()
        local selected = {}
        for value, state in pairs(self.Value) do
            if state then
                table.insert(selected, value)
            end
        end
        return selected
    end

    
    AutoSellDropDown:OnChanged(function()
        local selectedrnrarities = {}
        for _, value in ipairs(AutoSellDropDown:GetSelectedValues()) do
            table.insert(selectedrnrarities, value)
        end
        updateRaritiesFile(selectedrnrarities) -- Обновляем файл с рарностями
    end)

    local function enableautosell(rarity)
        local args = {
            [1] = "General",
            [2] = "Eggs",
            [3] = "AutoSell",
            [4] = rarity
        }
        game:GetService("ReplicatedStorage"):WaitForChild("Remotes"):WaitForChild("Bridge"):FireServer(unpack(args))
    end
    
    local function enableautosellshiny(rarity)
        local args = {
            [1] = "General",
            [2] = "Eggs",
            [3] = "AutoSell",
            [4] = rarity .. "_Shiny"
        }
        game:GetService("ReplicatedStorage"):WaitForChild("Remotes"):WaitForChild("Bridge"):FireServer(unpack(args))
    end

    getgenv().AutoSellShiny = false
    local AutoSellShiny = Tabs.Eggs:CreateToggle("Auto Sell", {Title = "Auto sell Shiny", Default = false, Description = "Works only with enabled Auto Sell"})

    AutoSellShiny:OnChanged(function(state)
        getgenv().AutoSellShiny = state
    end)


    local function containsValueRarity(value, list)
    for _, v in ipairs(list) do
        if v == value then
            return true
        end
    end
    return false
end
AutoSell:OnChanged(function(state)
    getgenv().AutoSell = state
    writefile(EnabledOrDisabledfolderPath, tostring(state)) -- Сохраняем текущее состояние в файл
    while getgenv().AutoSell do
        task.wait(0.15) -- Задержка для предотвращения перегрузки
        local RaritiesFolder = game:GetService("Players").LocalPlayer.PlayerGui.UI.HUD.Gacha.Frame.Pages.Sell.List.List
        if RaritiesFolder then
            local Values = {} -- Создаем таблицу для хранения выбранных значений
            for _, value in ipairs(AutoSellDropDown:GetSelectedValues()) do
                table.insert(Values, value) -- Заполняем таблицу выбранными значениями
            end

            for _, rarity in ipairs(RaritiesFolder:GetChildren()) do
                if rarity:IsA("Frame") then
                    -- Проверяем, содержится ли rarity в значениях AutoSellDropDown
                    local isSelected = containsValueRarity(rarity.Name, Values)
                    local currenton = rarity:FindFirstChild("On")
                    local currentoff = rarity:FindFirstChild("Off")
                    local currentshinyon = rarity:FindFirstChild("ShinyOn")
                    local currentshinyoff = rarity:FindFirstChild("ShinyOff")
                    -- Проверяем состояние перед включением авто-продажи
                    if isSelected then
                        -- Если авто-продажа была выключена вручную, включаем её обратно
                        if currenton and not currenton.Visible and currentoff and currentoff.Visible then
                                enableautosell(tostring(rarity.Name))
                            end

                        -- Проверяем состояние для авто-продажи shiny
                        if getgenv().AutoSellShiny then
                            if currentshinyon and not currentshinyon.Visible and currentshinyoff and currentshinyoff.Visible then
                                    enableautosellshiny(tostring(rarity.Name))
                                end
                            end
                        end
                    end
                end
        else
            print("Rarities Folder не найден")
        end
    end
end)

    local savedWolrdString = readfile(WorldfolderPath)
    getgenv().SavedWorld = tostring(savedWolrdString)
        -- Чтение сохраненной позиции из файла
    local savedPositionString = readfile(PositionfolderPath)
    local positionValues = {}

    -- Разделяем строку на отдельные координаты
    for value in string.gmatch(savedPositionString, "[^,]+") do
        table.insert(positionValues, tonumber(value))
    end

    -- Проверяем, что у нас есть три координаты
    if #positionValues == 3 then
        -- Создаем CFrame из координат
        getgenv().SavedPosition = CFrame.new(positionValues[1], positionValues[2], positionValues[3])
        print("Сохраненная позиция установлена:", getgenv().SavedPosition)
    else
        warn("Ошибка: неверное количество координат в файле.")
    end

    local currentPositionParagraph = Tabs.Trials:CreateParagraph("Current pos paragraph", {
        Title = "Current Position",
        Content = "World: "..savedWolrdString.."\nPosition: "..savedPositionString
    })
    
    local function updatePositionAndMap()
        -- Получаем текущее сохраненное состояние мира
        for _, v in ipairs(workspace.Client.Maps:GetChildren()) do
            getgenv().SavedWorld = v.Name
            writefile(WorldfolderPath, v.Name)
        end
    
        -- Получаем новую позицию
        getgenv().SavedPosition = CFrame.new(character.HumanoidRootPart.Position)
        writefile(PositionfolderPath, tostring(getgenv().SavedPosition.x)..","..tostring(getgenv().SavedPosition.y)..","..tostring(getgenv().SavedPosition.z))
        -- Обновляем содержимое параграфа
        currentPositionParagraph:SetValue("World: " .. tostring(getgenv().SavedWorld) .. "\nPosition: " .. tostring(getgenv().SavedPosition))
    end
    
    Tabs.Trials:CreateButton({
        Title = "Save New Position",
        Description = "Change your position for auto teleport",
        Callback = function()
            -- Вызываем функцию обновления позиции и карты
            updatePositionAndMap()
        end
    })
    
    local function teleportToSavedPosition()
        if getgenv().SavedPosition and getgenv().SavedWorld then
            local args = {
                [1] = "General",
                [2] = "Maps",
                [3] = "Teleport",
                [4] = getgenv().SavedWorld
            }
    
            -- Отправляем запрос на телепортацию
            game:GetService("ReplicatedStorage"):WaitForChild("Remotes"):WaitForChild("Bridge"):FireServer(unpack(args))
            wait(2)
    
            -- Телепортируем персонажа на сохраненную позицию
            character.HumanoidRootPart.CFrame = getgenv().SavedPosition
        else
            warn("Saved world or position is not set.")
        end
    end

    Tabs.Trials:CreateButton({
        Title = "Teleport To Saved Position",
        Description = "",
        Callback = function()
            -- Вызываем функцию обновления позиции и карты
            teleportToSavedPosition()
        end
    })
    

    getgenv().TrialWaveLimit = 0
    local TrialWaveLimit = Tabs.Trials:CreateInput("TrialWaveLimit", {
        Title = "Trial Wave Limit",
        Default = 0, 
        Description = "On this wave script will auto leave",
        Numeric = true,
        Finished = false,
        Callback = function(Value)
            getgenv().TrialWaveLimit = tonumber(Value)
        end
    })
    TrialWaveLimit:OnChanged(function(Value)
        getgenv().TrialWaveLimit = tonumber(Value)
    end)
    
    local AutoTrial = Tabs.Trials:CreateToggle("Auto Trial",{
        Title = "Auto Trial",
        Default = false,
        Description = ""
    })

    local TrialEnemiesFolder = workspace.Server.Trial.Enemies

    local function findNearestEnemyInTrial()
        local closestEnemy = nil
        local closestDistance = math.huge
        local rootPart = findHumanoidRootPart()
        for _, enemy in pairs(TrialEnemiesFolder:GetDescendants()) do
            if enemy:IsA("Part") and tonumber(enemy:GetAttribute("Health")) > 0 then
                local distance = (rootPart.Position - enemy.Position).Magnitude
    
                if distance < closestDistance then
                    closestDistance = distance
                    closestEnemy = enemy
                end
            end
        end
    
        return closestEnemy
    end

    local function teleportMeToNearestEnemyInTrial()

    
        local nearestEnemy = findNearestEnemyInTrial()
        local rootPart = findHumanoidRootPart()
        if nearestEnemy then
            local targetRootPart = nearestEnemy
            local distanceToEnemy = (rootPart.Position - targetRootPart.Position).Magnitude
            if distanceToEnemy > teleportRadius then
                rootPart.CFrame = CFrame.new(targetRootPart.Position + Vector3.new(0, 0, 3), targetRootPart.Position) -- Телепортируемся за врага
            end
        end
    end

    local function teleportPetsToNearestEnemyInTrial()

    
        local nearestEnemy = findNearestEnemyInTrial()

        if nearestEnemy then
            local targetRootPart = nearestEnemy
            local pets = getPets()
            for i, v in pets do
                    local petrootpart = v.HumanoidRootPart
                    local distanceToPet = (targetRootPart.Position - petrootpart.Position).Magnitude
            
                    if distanceToPet > teleportRadiusForPet then
                        petrootpart.CFrame = CFrame.new(targetRootPart.Position + Vector3.new(0, 0, 3), targetRootPart.Position) -- Телепортируем питомца за врага
                    end
            end
        end
    end

    local function sendPetsOnNearestEnemyInTrial()
        local nearestEnemy = findNearestEnemyInTrial()
        local EquipedPets = getEquipedPets()
        for i, v in EquipedPets do
            local rnpetcheck = tostring(game:GetService("Players").LocalPlayer).."---"..v
            if not nearestEnemy:FindFirstChild("Info"):FindFirstChild("Pets"):FindFirstChild(rnpetcheck) then
            teleportPetsToNearestEnemyInTrial()
            local args = {
                [1] = "General",
                [2] = "Pets",
                [3] = "Attack",
                [4] = v,
                [5] = nearestEnemy
            }
            
            game:GetService("ReplicatedStorage"):WaitForChild("Remotes"):WaitForChild("Bridge"):FireServer(unpack(args))
        end
        end
    end

    getgenv().StopFarmingTrial = true
    AutoTrial:OnChanged(function(state)
        getgenv().AutoTrial = state
    
            local function checkTime()
                while getgenv().AutoTrial == true do
                    local currentTime = os.date("*t")  -- Получаем текущее время
                    local minutes = currentTime.min
                    local seconds = currentTime.sec
                    -- Проверяем, если минуты равны 0 или 30
                    if (minutes == 0) and (seconds > 10) then
                        getgenv().StopFarmingTrial = false
                        wait(1)
                        local mapsf = workspace.Client.Maps
                        for i ,v in ipairs(mapsf:GetChildren()) do
                            if v.Name ~= "Lobby" then
                                wait(1)
                                local args = {
                                    [1] = "General",
                                    [2] = "Maps",
                                    [3] = "Teleport",
                                    [4] = "Lobby"
                                }
                        
                                -- Отправляем запрос на телепортацию
                                game:GetService("ReplicatedStorage"):WaitForChild("Remotes"):WaitForChild("Bridge"):FireServer(unpack(args))
        
                            end
                        end
                        wait(2)
                        local args = {
                            [1] = "Enemies",
                            [2] = "Trial_Easy",
                            [3] = "Join"
                        }
                        
                        game:GetService("ReplicatedStorage"):WaitForChild("Remotes"):WaitForChild("Bridge"):FireServer(unpack(args))
                        

                    end
        
                    -- Ждем 1 секунду перед следующей проверкой
                    wait(1)
                end
            end

            coroutine.wrap(checkTime)()
            
            local function checkcurrentwave()
                while getgenv().AutoTrial do
                    task.wait(10)
                    local waveText = game:GetService("Players").LocalPlayer.PlayerGui.UI.HUD.Trial.Frame.Frame.Content.Frame.Wave.Wave.Text
                    local waveNumber = tonumber(string.match(waveText, "%d+"))
                    local trialWaveLimit = tonumber(getgenv().TrialWaveLimit)
                    if waveNumber and trialWaveLimit and waveNumber >= trialWaveLimit and not getgenv().StopFarmingTrial then
                        print("Достигнут лимит волн, телепортируем...")
                        getgenv().StopFarmingTrial = true
                        wait(1)
                        teleportToSavedPosition()
                    end
                end
            end
            
            -- Запускаем корутину
            coroutine.wrap(checkcurrentwave)()

            while getgenv().AutoTrial do
                task.wait()
                for _, enemy in ipairs(TrialEnemiesFolder:GetDescendants()) do
                    if enemy:IsA("Part") then
                        -- Проверяем здоровье и состояние врага
                        if tonumber(enemy:GetAttribute("Health")) > 0 and getgenv().AutoTrial == true and getgenv().StopFarmingTrial == false then
                            teleportMeToNearestEnemyInTrial()
                            sendPetsOnNearestEnemyInTrial()
                            wait()
                        end
                    end
                end

            end


    end)


    local DeleteNotifications = Tabs.Misc:CreateButton({
        Title = "Enable/Disable Notifications",
        Description = "",
        Callback = function()
            local notifications = game:GetService("Players").LocalPlayer.PlayerGui.UI.HUD.Notifications
            notifications.Visible  = not notifications.Visible
            
        end
    })


    local RemoveEggAnimation = Tabs.Eggs:CreateButton({
        Title = "Remove Egg Animation", 
        Description = "",
        Callback = function()
            game:GetService("Players").LocalPlayer.PlayerScripts.Shalom.General.Scripts.Eggs.Egg_Template:Destroy()
        end
    })

    local Passivelist = {}
    if require then
    local function UpdatePassivesList()
        local Passives = {}
        local Players = game:GetService("Players")
        local sigma = Players.LocalPlayer
        local success, sigma2 = pcall(function()
            return require(sigma.PlayerScripts.Shalom)
        end)
    
        if not success then
            return
        end
    
        local passivesData = sigma2.Shared.Passives
    
        if type(passivesData) == "table" then
            for passivename, d in pairs(passivesData) do
                table.insert(Passives, passivename)
            end
        end
    
        -- Сортируем Passives по алфавиту, ставя "Fairy" в самый верх
        table.sort(Passives, function(a, b)
            if a == "Fairy" then
                return true -- "Fairy" всегда выше
            elseif b == "Fairy" then
                return false -- "Fairy" всегда выше
            else
                return a < b -- Сравниваем по алфавиту
            end
        end)
    
        return Passives
    end

    
    Passivelist = UpdatePassivesList()
    else
        Passivelist = {}
    end
    local function getExistingUnitIds()
        local petsFolder = game:GetService("Players").LocalPlayer:FindFirstChild("Pets")
        if petsFolder then
            local existingUnitIds = {}
            for _, child in pairs(petsFolder:GetChildren()) do
                if child:IsA("Folder") then
                    local stringfortable = tostring(child:GetAttribute("Name")) .. " | Passive: " .. tostring(child:GetAttribute("Passive")) .. " | Level: " .. tostring(child:GetAttribute("Level")) .. " | ID: " .. tostring(child.Name)
                    table.insert(existingUnitIds, stringfortable) -- Добавляем имя папки (unitid) в список
                end
            end
            return existingUnitIds
        end
    end

    
    
    local petslist = getExistingUnitIds()
    local PassiveParagraph = Tabs.Rerolls:CreateParagraph("Current Passive", {
        Title = "Current Passive: ",
        Content = nil
    })

    local PetsDropdown = Tabs.Rerolls:CreateDropdown("Pets Dropdown", {Title = "Select Pet For Auto Reroll Passive", Description = "", Values = petslist, Multi = false, Default = ""})
    local PassivesDropdown = Tabs.Rerolls:CreateDropdown("Passives Dropdown", {Title = "Select Passive For Auto Reroll Passive", Description = "Allows Multi", Values = Passivelist, Multi = true, Default = {}})
    
    local function getselectedid()
        local selectedPet = PetsDropdown.Value
        if selectedPet and type(selectedPet) ~= "table" then
            -- Извлекаем ID из выбранного питомца
            local idStart = selectedPet:find("ID: ") -- Находим начало ID
            if idStart then
                local id = selectedPet:sub(idStart + 4) -- Извлекаем ID
                return id
            end
        end
        return nil -- Если ничего не выбрано или ID не найден
    end
    
    local function updatePetsDropdownAndSelect()
        local selectedId = getselectedid()
        local newpetlist = getExistingUnitIds()
        PetsDropdown:SetValues(newpetlist) -- Устанавливаем новые значения в выпадающий список
    
        -- Получаем ID выбранного питомца
        if selectedId then
            -- Ищем питомца с соответствующим ID в новом списке
            for _, pet in pairs(newpetlist) do
                if pet:find("ID: " .. selectedId) then
                    PetsDropdown:SetValue(pet) -- Устанавливаем выбранный питомец
                    break -- Выходим из цикла, если нашли
                end
            end
        end
    end
    
    local RefreshPets = Tabs.Rerolls:CreateButton({
        Title = "Refresh Pets",
        Description = "",
        Callback = function()
            updatePetsDropdownAndSelect() -- Обновляем и выбираем питомца
        end
    })

    function PassivesDropdown:GetSelectedValues()
        local selected = {}
        for value, state in pairs(self.Value) do
            if state then
                table.insert(selected, value)
            end
        end
        return selected
    end

    local function checkpassiveofpet(pet)
        local petfolder = game:GetService("Players").LocalPlayer.Pets
        local currentpet = petfolder:FindFirstChild(pet)
        if currentpet then
            local currentpassive = tostring(currentpet:GetAttribute("Passive"))
            PassiveParagraph:SetValue(currentpassive)
            return currentpassive

        end
    end

    local function rerollPassive(pet)
        local args = {
            [1] = "General",
            [2] = "Passives",
            [3] = "Open",
            [4] = pet,
            [5] = "Ruby",
            [6] = {}
        }
        
        game:GetService("ReplicatedStorage"):WaitForChild("Remotes"):WaitForChild("Bridge"):FireServer(unpack(args))
    end

    local AutoRerollPassive = Tabs.Rerolls:CreateToggle("Auto Reroll passive",{Title = "Auto Roll For Selected Passive", Description = "", Default = false})

    AutoRerollPassive:OnChanged(function(state)
        getgenv().AutoRollPassive = state
        while getgenv().AutoRollPassive do
            task.wait()
            local selectedPetId = getselectedid()
            local selectedPassives = PassivesDropdown:GetSelectedValues()
            if selectedPetId then
                local currentpassive = checkpassiveofpet(selectedPetId)
                if containsValue(currentpassive, selectedPassives) then
                    AutoRerollPassive:SetValue(false)
                    PetsDropdown:SetValue("")
                    updatePetsDropdownAndSelect()
                    getgenv().AutoRollPassive = false
                else
                    rerollPassive(selectedPetId)
                end
            end
        end

    end)

    local function getlistofavatars()
        local Players = game:GetService("Players")
        local player = Players.LocalPlayer
        local Shalom = require(player.PlayerScripts.Shalom)
        local Avatars = {}
            local ListOfAvatars = Shalom.Shared.Avatars
        
            if type(ListOfAvatars) == "table" then
                for i,v in pairs(ListOfAvatars) do
                    if tostring(i) ~= "Hawk" then
                        table.insert(Avatars, i)
                    end
                end
            end

            table.sort(Avatars)
        return Avatars
    end
    local AvatarsList = getlistofavatars()

    local AvatarsDropdown = Tabs.Rerolls:CreateDropdown("Avatars Dropdown", {Title = "Select Avatars For Auto Reroll", Description = "Allows Multi", Values = AvatarsList , Multi = true, Default = {}})
    local AutoRerollAvatar = Tabs.Rerolls:CreateToggle("Auto Reroll Avatars",{Title = "Auto Roll For Selected Avatars", Description = "", Default = false})

    function AvatarsDropdown:GetSelectedValues()
        local selected = {}
        for value, state in pairs(self.Value) do
            if state then
                table.insert(selected, value)
            end
        end
        return selected
    end

    local function rerollAvatar()
        local args = {
            [1] = "General",
            [2] = "Avatars",
            [3] = "Open",
            [4] = "Sapphire"
        }
        
        game:GetService("ReplicatedStorage"):WaitForChild("Remotes"):WaitForChild("Bridge"):FireServer(unpack(args))
    end
    local function containsValueTable(selectedAvatars, currentAvatarslist)
        -- Проверяем, являются ли входные данные таблицами
        if type(selectedAvatars) ~= "table" then
            warn("Ошибка: selectedAvatars не является таблицей. Получено: " .. type(selectedAvatars))
            return false -- Если selectedAvatars не таблица, возвращаем false
        end
    
        if type(currentAvatarslist) ~= "table" then
            warn("Ошибка: currentAvatarslist не является таблицей. Получено: " .. type(currentAvatarslist))
            return false -- Если currentAvatarslist не таблица, возвращаем false
        end
    
        for _, selected in ipairs(selectedAvatars) do
            for _, current in ipairs(currentAvatarslist) do
                if selected == current then
                    return true -- Если найдено совпадение, возвращаем true
                end
            end
        end
        return false -- Если совпадений не найдено, возвращаем false
    end
    
    AutoRerollAvatar:OnChanged(function(state)
        getgenv().AutoRerollAvatar = state
        while getgenv().AutoRerollAvatar do
            task.wait()
            local selectedAvatars = AvatarsDropdown:GetSelectedValues()
            if selectedAvatars then
                local AvatarsFolder = player:FindFirstChild("Avatars")
                local currentAvatarslist = getExistingAvatars(AvatarsFolder)
    
                local foundAvatar = false -- Флаг для отслеживания, найден ли аватар
    
                -- Проверяем, есть ли хотя бы один выбранный аватар в текущем списке
                if containsValueTable(selectedAvatars, currentAvatarslist) then
                    AutoRerollAvatar:SetValue(false)
                    AvatarsDropdown:SetValue({})
                    getgenv().AutoRerollAvatar = false
                    foundAvatar = true -- Устанавливаем флаг, если аватар найден
                    break -- Выходим из цикла, если нашли
                end
    
                -- Если ни один аватар не найден, вызываем rerollAvatar
                if not foundAvatar and getgenv().AutoRerollAvatar then
                    rerollAvatar()
                end
            end
        end
    end)

    Tabs.AutoBuy:CreateParagraph("Aligned Paragraph", {
        Title = "Attention!",
        Content = "You must buy at least 1 of each item in merchant to use this feature!\n(If you buy ruby - ruby will appear in the list after script re-execute)",
        TitleAlignment = "Middle",
        ContentAlignment = Enum.TextXAlignment.Center
    })

    local StockFolder = player:FindFirstChild("Stock")
    local AvailableStock = getExistingStock(StockFolder)
    local StockDropdown = Tabs.AutoBuy:CreateDropdown("Stock Dropdown", {Title = "Select Item For Auto Buy From Merchant", Description = "Allows Multi", Values = AvailableStock , Multi = true, Default = {}})

    local AutoBuyStock = Tabs.AutoBuy:CreateToggle("Auto Buy Stock", {Title= "Auto Buy Selected From Merchant", Description = "Auto Buy Stock", Default = false})

    local function buystock(nameofstock)
        local args = {
            [1] = "General",
            [2] = "Merchant",
            [3] = "Buy",
            [4] = nameofstock,
            [5] = 1,
            [6] = "Trial Shard"
        }
        
        game:GetService("ReplicatedStorage"):WaitForChild("Remotes"):WaitForChild("Bridge"):FireServer(unpack(args))
        
    end


    function StockDropdown:GetSelectedValues()
        local selected = {}
        for value, state in pairs(self.Value) do
            if state then
                table.insert(selected, value)
            end
        end
        return selected
    end

    AutoBuyStock:OnChanged(function(state)
        getgenv().AutoBuyStock = state

        while getgenv().AutoBuyStock do
            task.wait()
            local selectedStocks = StockDropdown:GetSelectedValues()
            if selectedStocks then
                local StockFolder = player:FindFirstChild("Stock")
                local currentStockList = getExistingStock(StockFolder)
    
                -- Проверяем, есть ли хотя бы один выбранный аватар в текущем списке
                for i, v in pairs(currentStockList) do
                    local currentcheck = v
                    if containsValue(currentcheck, selectedStocks) then
                        local valueofstock = tonumber(StockFolder:FindFirstChild(currentcheck):GetAttribute("Amount"))
                        if valueofstock > 0 then
                            buystock(currentcheck)
                        end
                    end
                end
            end
        end

    end)



    local function delayedTeleport()
        task.wait(10)  -- Задержка в 10 секунд
        teleportToSavedPosition()  -- Вызов функции телепортации
    end
    coroutine.wrap(delayedTeleport)()

end


SaveManager:SetLibrary(Library)
InterfaceManager:SetLibrary(Library)
SaveManager:IgnoreThemeSettings()
SaveManager:SetIgnoreIndexes({})
InterfaceManager:SetFolder("Apel Hub")
SaveManager:SetFolder("Apel Hub/"..tostring(gamename))
InterfaceManager:BuildInterfaceSection(Tabs.Settings)
SaveManager:BuildConfigSection(Tabs.Settings)
SaveManager:LoadAutoloadConfig()

local Menu = game:GetService("CoreGui"):FindFirstChild("Menu")
if Menu then
    print("Найдено меню")
else
    local Menu = Instance.new("ScreenGui")
Menu.Name = "Menu"
local Frame = Instance.new("Frame")
Frame.Name = "Menu Button"
local ImageButton = Instance.new("ImageButton")
local UIAspectRatioConstraint = Instance.new("UIAspectRatioConstraint")
local UIAspectRatioConstraint_2 = Instance.new("UIAspectRatioConstraint")

--Properties:
local coreGui = game:GetService("CoreGui")
Menu.Parent = coreGui
Menu.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

Frame.Parent = Menu
Frame.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Frame.BorderColor3 = Color3.fromRGB(0, 0, 0)
Frame.BorderSizePixel = 0
Frame.Position = UDim2.new(0.167999998, 0, 0.230493277, 0)
Frame.Size = UDim2.new(0.040533334, 0, 0.0681614354, 0)

ImageButton.Parent = Frame
ImageButton.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
ImageButton.BorderColor3 = Color3.fromRGB(0, 0, 0)
ImageButton.BorderSizePixel = 0
ImageButton.Size = UDim2.new(1, 0, 1, 0)
ImageButton.Image = "http://www.roblox.com/asset/?id=181239831"
ImageButton.MouseButton1Up:Connect(function()
    game:GetService("VirtualInputManager"):SendKeyEvent(true,"LeftControl",false,game)
end)

UIAspectRatioConstraint.Parent = ImageButton

UIAspectRatioConstraint_2.Parent = Frame
end
